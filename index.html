<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <title>Rust 101</title>
    <link rel="stylesheet" type="text/css" href="build/build.css">
    <link rel="stylesheet" type="text/css" href="http://fonts.googleapis.com/css?family=Patua+One">
  </head>
  <body>
    <article>
      <section>
        <h1 class="full-slide">Rust 101</h1><img src="images/rust_logo.png" class="logo-big">
      </section>
      <section>
        <h2>What?</h2>
      </section>
      <section>
        <h2>Low-level</h2>
      </section>
      <section>
        <h2>Safe</h2>
      </section>
      <section>
        <h2>Zero-cost abstractions</h2>
      </section>
      <section>
        <h2>Why?</h2>
      </section>
      <section><img src="images/twitter-in-servo.jpg" class="logo-big"></section>
      <section>
        <pre><code class="language-rust">fn main() {
    println!("hello world")
}
</code></pre>
      </section>
      <section>
        <h2>Basic structures</h2>
        <pre><code class="language-rust">fn main() {
    let my_name = "Tim";
    println!("Hello {}", my_name);
}
</code></pre>
      </section>
      <section>
        <pre><code class="language-rust">for index in range(0i, 10i) {
    println!("index: {}", index);
}
</code></pre>
      </section>
      <section>
        <pre><code class="language-rust">const RUN_TO: int = 100;
let mut n = 1;

while n <= RUN_TO {
    if n % 15 == 0 {
        println!("fizzbuzz");
    } else if n % 3 == 0 {
        println!("fizz");
    } else if n % 5 == 0 {
        println!("buzz");
    } else {
        println!("{}", n);
    }
    
    n += 1;
}
</code></pre>
      </section>
      <section>
        <h2>More fun structures</h2>
        <pre><code class="language-rust">loop {
    println!("again, again!");
}</code></pre>
      </section>
      <section>
        <pre><code class="language-rust">match x {
    1 => println!("One!"),
    2 => println!("Two!"),
    3 => println!("Many!"),
    4 => println!("Lots!"),
    5 | 6 => println!("Er"),
    7...10 => println!("Um"),
    _ => println!("What?")
}
</code></pre>
      </section>
      <section>
        <pre><code class="language-rust">let pair = (123i, 456i);

match pair {
    (456, _) => println!("1st part is 456"),
    (_, 123) => println!("2nd part is 123"),
    (a, b) if a > b => println!("A greater: {}", a),
    (a, b) if b > a => println!("B greater: {}", b),
    (_, _) => println!("Who knows")
}
</code></pre>
      </section>
      <section>
        <h2>Functions</h2>
        <pre><code class="language-rust">fn add(x: int, y: int) -> int {
    return x + y;
}
</code></pre>
      </section>
      <section>
        <h2>Functions</h2>
        <pre><code class="language-rust">fn add(x: int, y: int) -> int {
    x + y
}
</code></pre>
      </section>
      <section>
        <pre><code class="language-rust">let add = |x: int, y: int| { x + y };
</code></pre>
      </section>
      <section>
        <h2>Objects</h2>
        <pre><code class="language-rust">struct Point {
    x: int,
    y: int
}

fn main() {
    let point = Point { x: 0, y: 0 };
}
</code></pre>
      </section>
      <section>
        <pre><code class="language-rust">struct Circle {
    x: int,
    y: int,
    radius: int
}

impl Circle {
    fn max_x(&self) -> int {
        self.x + self.radius
    }
}
</code></pre>
      </section>
      <section>
        <pre><code class="language-rust">struct Circle {
    x: int,
    y: int,
    radius: int
}

impl Circle {
    fn expand(&mut self) {
        self.radius = self.radius + 1;
    }
}
</code></pre>
      </section>
      <section>
        <pre><code class="language-rust">struct Circle {
    x: int,
    y: int,
    radius: int
}

impl Circle {
    fn new(x: int, y: int, radius: int) -> Circle {
        return Circle { x: x, y: y, radius: radius };
    }
}

fn main() {
    Circle::new(0, 0, 100);
}
</code></pre>
      </section>
      <section>
        <h2>Enums</h2>
        <pre><code class="language-rust">enum Colour {
    Red, Green, Blue
}

let x = Red;
</code></pre>
      </section>
      <section>
        <pre><code class="language-rust">enum MaybeInt {
    AnInt(int),
    NoInt
}

let x: MaybeInt = AnInt(1);
let y: MaybeInt = NoInt;
</code></pre>
      </section>
      <section>
        <pre><code class="language-rust">enum Option&lt;T&gt; {
    Some(T),
    None
}
</code></pre>
      </section>
      <section>
        <pre><code class="language-rust">enum Result&lt;T, ErrorT&gt; {
    Ok(T),
    Err(ErrorT)
}
</code></pre>
      </section>
      <section>
        <h2>Exceptions</h2>
        <pre><code class="language-rust">fn could_fail(x: int) -> Result&lt;int, String&gt; {
    if x >= 0 {
        return Ok(x);
    } else {
        return Err(format!("{} was less than 0", x));
    }
}

fn main() {
    let result = could_fail(-1);
    match result {
        Ok(x) => println!("{} is ok!", x),
        Err(msg) => println!("Error! Message was: {}", msg)
    }
}
</code></pre>
      </section>
      <section>
        <h2>Concurrency</h2>
        <pre><code class="language-rust">spawn(proc() {
    println!("Hi, from another thread!", x);          
});
</code></pre>
      </section>
      <section>
        <h2>Concurrency</h2>
        <pre><code class="language-rust">fn main() {
    let (tx, rx) = channel();
    
    spawn(proc() {
        tx.send("Hi there!");
    });
    
    let response = rx.recv();
    println!("Response: {}", response);
}
</code></pre>
      </section>
      <section>
        <h2>Macros</h2>
        <pre><code class="language-rust">println!("x={}", 1, 2, 3);
</code></pre>
      </section>
      <section>
        <h2>Macros</h2>
        <pre><code class="language-rust">let bad_query = sql!("SELECT * FORM users WHERE name = $1");
</code></pre>
      </section>
      <section>
        <h2>Pointers</h2>
        <pre><code class="language-clike">int my_function() {
    int x = 0;
    
    int* x_address = &x;
    *x_address = 5;
    
    int y = *x_address;
    return y;
}</code></pre>
        <aside>
          <ul>
            <li>This is C</li>
            <li>X is a local variable, which means on the stack</li>
            <li>Which means gone after this function ends</li>
            <li>x is an int, but x_address is an int*; this means pointer to int</li>
            <li>&x gets the address of x</li>
            <li>*x_address gets the value at the end of x_address pointer</li>
            <li>y == x</li>
          </ul>
        </aside>
      </section>
      <section>
        <h2>Rust Pointers</h2>
        <pre><code class="language-rust">fn my_function() -> int {
    let mut x = 0;
    
    let x_address = &mut x;
    *x_address = 5;
    
    let y = *x_address;
    return y;
}
</code></pre>
      </section>
      <section>
        <h2>Dangling pointers</h2>
        <pre><code class="language-clike">int my_function() {
    int x = 5;
    return &x;
}
</code></pre>
      </section>
      <section>
        <h2>Lifetimes</h2>
        <pre><code class="language-rust">fn my_function() -> &int {
    let x = 5;
    return &x;
}

fn main() {
    let y = my_function();
}
</code></pre>
      </section>
      <section>
        <h2>Heap Pointers</h2>
        <pre><code class="language-clike">int main() {
    int* heapVariable = malloc(sizeof(int));
    
    ...
    
    free(heapVariable);
}
</code></pre>
      </section>
      <section>
        <h2>Heap Pointers in Rust</h2>
        <pre><code class="language-rust">fn main() {
    let x = box 10i;
    println!("X = {}", x);
}
</code></pre>
      </section>
      <section>
        <pre><code class="language-rust">fn make_x() -> Box<int> {
    let x = box 10i;
    return x;
}

fn main() {
    let x = make_x();
    println!("X = {}", x);
}
</code></pre>
      </section>
      <section>
        <pre><code class="language-rust">use std::rc::Rc;

fn main() {
    let x = Rc::new(10i);
    println!("X = {}", x);
}
</code></pre>
      </section>
      <section>
        <h2>Real Code</h2>
        <pre><code class="language-rust">extern crate nickel;
extern crate rustache;

use std::io::net::ip::Ipv4Addr;
use nickel::{ Nickel, Request, Response, HttpRouter };
use rustache::{ HashBuilder, FileError };

fn main() {
    let mut server = Nickel::new();
    
    // GET to /hello just returns "hello world"
    fn hello_world_handler(_: &Request, response: &mut Response) { 
        response.send("hello world"); 
    }
    
    server.get("/hello", hello_world_handler);
    
    // POST to /echo returns "You sent: [post body text]"
    fn echo_handler(request: &Request, response: &mut Response) {
        let input = &request.origin.body;
        response.send(format!("You sent: {}\n", input));
    }
    
    server.post("/echo", echo_handler);
    
    // GET to / renders an HTML templated page
    fn render_home(_: &Request, response: &mut Response) {
        let view_model = HashBuilder::new()
                         .insert_string("title", "Rustacular")
                         .insert_string("content", "Content!");
                         
        let render = rustache::render_file("index.html", view_model);
        
        response.send(match render {
            Ok(mut stream) => stream.read_to_string().unwrap(),
            Err(FileError(error)) => error,
            Err(_) => "Unknown error".to_string()
        });
    }
    
    server.get("/", render_home);
    
    server.listen(Ipv4Addr(0, 0, 0, 0), 6767);
}
</code></pre>
      </section>
      <section>
        <h1 class="full-slide">Any questions?</h1>
      </section>
    </article>
    <script src="build/build.js"></script>
  </body>
</html>